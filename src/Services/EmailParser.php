<?php

declare(strict_types=1);

namespace App\Services;

/**
 * Сервис для парсинга email адресов из текста
 *
 * Парсит входной текст по разделителям (\n, ", ", " ", ";"), выполняет нормализацию
 * и возвращает массив уникальных email адресов.
 *
 * Поддерживаемые разделители:
 * - Переносы строк (\n, \r\n)
 * - Запятая с пробелом (", ")
 * - Точка с запятой с пробелом ("; ")
 * - Запятая перед переносом строки (",\n", ";\n")
 * - Одиночная запятая (",")
 * - Точка с запятой (";")
 * - Пробелы (" ")
 *
 * Особенности обработки:
 * - Автоматический trim каждого элемента
 * - Фильтрация пустых строк
 * - Удаление дубликатов
 * - Сохранение порядка первого вхождения
 *
 * @package App\Services
 * @author Vladimir Matkovskii and Claude 4 Sonnet
 * @version 1.2
 */
class EmailParser
{
    /**
     * Разделители для парсинга email адресов
     *
     * Порядок разделителей важен для корректной обработки:
     * - Сначала обрабатываются более специфичные разделители (\r\n, \n)
     * - Затем комбинированные разделители (",\n", ";\n")
     * - Затем запятая с пробелом и точка с запятой с пробелом для стандартного CSV формата
     * - Далее одиночная запятая и точка с запятой как распространенные разделители
     * - В конце одиночные пробелы как самый общий разделитель
     *
     * Такой порядок предотвращает неправильное разбиение при смешанных форматах
     * и обеспечивает корректную обработку всех возможных комбинаций разделителей.
     */
    private const SEPARATORS = [
        "\r\n",  // Windows переносы строк (должен быть перед \n)
        "\n",    // Unix/Linux переносы строк
        ",\n",   // Запятая перед переносом строки (часто встречается в реальных данных)
        ";\n",   // Точка с запятой перед переносом строки
        ", ",    // Запятая с пробелом (стандартный CSV формат)
        "; ",    // Точка с запятой с пробелом (альтернативный CSV формат)
        ",",     // Одиночная запятая (для обработки случаев без пробела)
        ";",     // Точка с запятой (альтернативный CSV разделитель)
        " ",     // Пробелы (обрабатывается последним)
    ];

    /**
     * Парсит текст с email адресами в массив
     *
     * Основной метод класса. Разбивает входной текст по всем поддерживаемым
     * разделителям, нормализует данные и возвращает очищенный массив.
     *
     * Алгоритм обработки:
     * 1. Последовательное разбиение по разделителям
     * 2. Trim каждого элемента
     * 3. Фильтрация пустых элементов
     * 4. Удаление дубликатов с сохранением порядка
     *
     * Метод безопасен для обработки любых входных данных и не выбрасывает исключения.
     * В случае пустого входного текста возвращает пустой массив.
     *
     * @param string $text Входной текст с email адресами
     * @return array Массив уникальных email адресов
     *
     * @example
     * $parser = new EmailParser();
     * $emails = $parser->parse("user1@test.com, user2@test.com\nuser3@test.com; user4@test.com");
     * // Результат: ["user1@test.com", "user2@test.com", "user3@test.com", "user4@test.com"]
     */
    public function parse(string $text): array
    {
        // Начинаем с исходного текста как единого элемента
        $items = [$text];

        // Последовательно разбиваем по каждому разделителю
        // Используем константу для обеспечения консистентности
        foreach (self::SEPARATORS as $separator) {
            $items = $this->splitBySeparator($items, $separator);
        }

        // Нормализуем данные: trim + фильтрация пустых
        $cleanItems = $this->normalizeItems($items);

        // Удаляем дубликаты с сохранением порядка первого вхождения
        return $this->removeDuplicates($cleanItems);
    }

    /**
     * Разбивает массив элементов по указанному разделителю
     *
     * Каждый элемент входного массива разбивается по разделителю,
     * результаты объединяются в плоский массив.
     *
     * Метод безопасен для обработки смешанных типов данных - если элемент
     * не является строкой, он передается дальше без изменений.
     *
     * @param array $items Массив элементов для разбиения
     * @param string $separator Разделитель для разбиения
     * @return array Плоский массив разбитых элементов
     */
    private function splitBySeparator(array $items, string $separator): array
    {
        $result = [];

        foreach ($items as $item) {
            // Проверяем, что элемент является строкой
            // Не строковые элементы передаются без изменений
            if (!is_string($item)) {
                $result[] = $item;
                continue;
            }

            // Разбиваем по разделителю только если он присутствует
            // Это предотвращает создание лишних элементов массива
            if (str_contains($item, $separator)) {
                $splitItems = explode($separator, $item);
                $result = array_merge($result, $splitItems);
            } else {
                $result[] = $item;
            }
        }

        return $result;
    }

    /**
     * Нормализует элементы массива
     *
     * Выполняет trim каждого элемента и фильтрует пустые строки.
     * Также приводит все элементы к строковому типу для консистентности.
     * Очищает элементы от разделителей, которые могли остаться в конце или начале.
     *
     * Этот метод является критически важным для качества парсинга:
     * - Убирает лишние пробелы в начале и конце
     * - Удаляет оставшиеся разделители (запятые, точки с запятой)
     * - Фильтрует пустые элементы, которые могут появиться при разбиении
     * - Обеспечивает единообразный тип данных на выходе
     *
     * @param array $items Массив элементов для нормализации
     * @return array Массив нормализованных строк
     */
    private function normalizeItems(array $items): array
    {
        $normalized = [];

        foreach ($items as $item) {
            // Приводим к строке и убираем пробелы в начале и конце
            // Приведение к строке безопасно для любых типов данных
            $cleanItem = trim((string)$item);
            
            // Очищаем от оставшихся разделителей в конце и начале строки
            $cleanItem = trim($cleanItem, ",; \n\r");

            // Пропускаем пустые элементы после trim
            // Это важно для удаления артефактов разбиения
            if ($cleanItem !== '') {
                $normalized[] = $cleanItem;
            }
        }

        return $normalized;
    }

    /**
     * Удаляет дубликаты из массива с сохранением порядка
     *
     * Использует array_unique для удаления дубликатов.
     * Сохраняет порядок первого вхождения каждого элемента.
     *
     * array_values используется для переиндексации массива после удаления дубликатов,
     * что обеспечивает консистентную структуру данных без пропусков в индексах.
     *
     * @param array $items Массив с возможными дубликатами
     * @return array Массив без дубликатов с переиндексированными ключами
     */
    private function removeDuplicates(array $items): array
    {
        // array_unique сохраняет первое вхождение каждого элемента
        // array_values переиндексирует массив для получения последовательных ключей
        return array_values(array_unique($items));
    }

    /**
     * Получает информацию о поддерживаемых разделителях
     *
     * Возвращает массив всех разделителей, которые используются
     * для парсинга email адресов.
     *
     * Полезно для документирования API, тестирования и отладки.
     * Возвращает копию константы для предотвращения случайного изменения.
     *
     * @return array Массив разделителей в порядке их обработки
     */
    public function getSupportedSeparators(): array
    {
        return self::SEPARATORS;
    }

    /**
     * Проверяет, содержит ли текст поддерживаемые разделители
     *
     * Полезно для определения, нужен ли парсинг или текст
     * содержит только один email адрес.
     *
     * Использует str_contains для эффективного поиска разделителей.
     * Возвращает true при первом найденном разделителе для оптимизации производительности.
     *
     * @param string $text Текст для проверки
     * @return bool True, если текст содержит хотя бы один разделитель
     */
    public function containsSeparators(string $text): bool
    {
        foreach (self::SEPARATORS as $separator) {
            if (str_contains($text, $separator)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Возвращает статистику парсинга
     *
     * Анализирует входной текст и возвращает информацию о процессе парсинга.
     * Полезно для отладки, мониторинга и анализа производительности.
     *
     * Включает:
     * - Длину исходного текста
     * - Количество найденных email адресов
     * - Информацию о наличии разделителей
     * - Статистику по каждому типу разделителя
     * - Список найденных email адресов
     *
     * @param string $text Входной текст для анализа
     * @return array Детальная статистика парсинга
     */
    public function getParseStatistics(string $text): array
    {
        $originalLength = strlen($text);
        $parsedEmails = $this->parse($text);
        $emailCount = count($parsedEmails);

        // Собираем статистику по каждому разделителю
        $separatorStats = [];
        foreach (self::SEPARATORS as $separator) {
            $separatorStats[$separator] = substr_count($text, $separator);
        }

        return [
            'original_length' => $originalLength,
            'parsed_emails_count' => $emailCount,
            'has_separators' => $this->containsSeparators($text),
            'separator_occurrences' => $separatorStats,
            'parsed_emails' => $parsedEmails
        ];
    }
}